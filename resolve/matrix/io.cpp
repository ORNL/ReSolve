#include <iostream>
#include <iomanip>
#include <string>
#include <fstream>
#include <sstream>

#include <resolve/utilities/logger/Logger.hpp>
#include <resolve/vector/Vector.hpp>
#include <resolve/matrix/Coo.hpp>
#include "io.hpp"


namespace ReSolve { namespace io {

  matrix::Coo* readMatrixFromFile(std::istream& file)
  {
    if(!file) {
      Logger::error() << "Empty input to readMatrixFromFile function ... \n" << std::endl;
      return nullptr;
    }

    std::stringstream ss;
    std::string line;
    index_type i = 0;
    index_type m, n, nnz;
    bool symmetric = false;
    bool expanded = true;
    std::getline(file, line);
    //symmetric?
    size_t found = line.find("symmetric");
    if (found != std::string::npos) {
      symmetric = true;
      expanded = false;
    } 
    while (line.at(0) == '%') {
      std::getline(file, line); 
      // std::cout<<line<<std::endl;
    }
    ss << line;
    ss >> n >> m >> nnz;

    //create coo arrays
    index_type* coo_rows = new index_type[nnz];
    index_type* coo_cols = new index_type[nnz];
    real_type* coo_vals = new real_type[nnz];
    index_type n_diagonal = 0;

    i = 0;
    index_type a, b;
    real_type c;
    while (file >> a >> b >> c) {
      coo_rows[i] = a - 1;
      coo_cols[i] = b - 1;
      coo_vals[i] = c;

      if (a == b) {
        n_diagonal++;
      }

      i++;
    }

    matrix::Coo* A = new matrix::Coo(n,
                                     m,
                                     nnz,
                                     symmetric,
                                     false,
                                     &coo_rows,
                                     &coo_cols,
                                     &coo_vals,
                                     memory::HOST,
                                     memory::HOST);
    A->setNnzExpanded((2 * nnz) - n_diagonal);

    return A;
  }


  real_type* readRhsFromFile(std::istream& file)
  {
    if(!file) {
      Logger::error() << "Empty input to " << __func__ << " function ... \n" << std::endl;
      return nullptr;
    }

    std::stringstream ss;
    std::string line;
    index_type i = 0;
    index_type n, m;

    std::getline(file, line);
    while (line.at(0) == '%') {
      std::getline(file, line); 
      // std::cout << line << std::endl;
    }
    ss << line;
    ss >> n >> m ;

    real_type* vec = new real_type[n];
    real_type a;
    while (file >> a){
      vec[i] = a;
      i++;
    }
    return vec;
  }

  void readAndUpdateMatrix(std::istream& file, matrix::Coo* A)
  {
    if(!file) {
      Logger::error() << "Empty input to readMatrixFromFile function ..." << std::endl;
      return;
    }

    std::stringstream ss;
    A->setExpanded(false);
    std::string line;
    index_type i = 0;
    index_type m, n, nnz;
    std::getline(file, line);
    while (line.at(0) == '%') {
      std::getline(file, line); 
      //  std::cout << line << std::endl;
    }

    ss << line;
    ss >> n >> m >> nnz;
    if ((A->getNumRows() != n) || (A->getNumColumns() != m) || (A->getNnz() < nnz)) {      
      Logger::error() << "Wrong matrix size: " << A->getNumRows()
                      << "x" << A->getNumColumns() 
                      << ", NNZ: " << A->getNnz()
                      << " Cannot update! \n ";
      return;
    }
    A->setNnz(nnz);
    //create coo arrays
    index_type* coo_rows = A->getRowData(memory::HOST);
    index_type* coo_cols = A->getColData(memory::HOST);
    real_type* coo_vals  = A->getValues( memory::HOST);
    i = 0;
    index_type a, b;
    real_type c;
    while (file >> a >> b >> c) {
      coo_rows[i] = a - 1;
      coo_cols[i] = b - 1;
      coo_vals[i] = c;
      i++;
    }
  }

  void readAndUpdateRhs(std::istream& file, real_type** p_rhs) 
  {
    if (!file) {
      Logger::error() << "Empty input to readAndUpdateRhs function ..." << std::endl;
      return;
    }

    real_type* rhs = *p_rhs;
    std::stringstream ss;
    std::string line;
    index_type n, m;

    std::getline(file, line);
    while (line.at(0) == '%') {
      std::getline(file, line); 
      // std::cout<<line<<std::endl;
    }
    ss << line;
    ss >> n >> m ;

    if (rhs == nullptr) {
      // std::cout << "Allocating array of size " << n << "\n";
      rhs = new real_type[n];
    } 
    real_type a;
    index_type i = 0;
    while (file >> a) {
      rhs[i] = a;
      // std::cout << i << ": " << a << "\n";
      i++;
    }
  }

  int writeMatrixToFile(matrix::Sparse* A, std::ostream& file_out)
  {
    if (A == nullptr) {
      Logger::error() << "Matrix pointer is NULL!\n";
      return -1;
    }

    if (A->symmetric() && !A->expanded()) {
      file_out << "%%MatrixMarket matrix coordinate real symmetric\n";
    } else {
      file_out << "%%MatrixMarket matrix coordinate real general\n";
    }
    file_out << "% Generated by Re::Solve <https://github.com/ORNL/ReSolve>\n";
    file_out << A->getNumRows()    << " " 
             << A->getNumColumns() << " "
             << A->getNnz()        << "\n";
    A->print(file_out);
    return 0;
  }

  int writeVectorToFile(vector_type* vec_x, std::ostream& file_out)
  {
    real_type* x_data = vec_x->getData(memory::HOST);
    // std::ofstream file_out (filename, std::ofstream::out);
    file_out << "%%MatrixMarket matrix array real general \n";
    file_out << "% ID: XXX \n";
    file_out << vec_x->getSize() << " " << 1 << "\n";
    for (int i = 0; i < vec_x->getSize(); ++i) {
      file_out << std::setprecision(32) << std::scientific << x_data[i] << "\n";
    }
    // file_out.close();
    return 0;
  }

}} // ReSolve::io
